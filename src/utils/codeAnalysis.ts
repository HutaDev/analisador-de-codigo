
import { SupportedLanguage } from './languageUtils';

export interface CodeIssue {
  line: number;
  column: number;
  message: string;
  severity: 'error' | 'warning' | 'info';
  code: string;
}

export interface CodeMetrics {
  linesOfCode: number;
  complexity: number;
  maintainability: number;
}

export interface AnalysisResult {
  issues: CodeIssue[];
  metrics: CodeMetrics;
  suggestions: string[];
  score: number;
}

// Simple code analysis function (placeholder for actual implementation)
export const analyzeCode = (code: string, language: SupportedLanguage): AnalysisResult => {
  // This is a simplified analysis - in a real app you'd integrate with linters/analyzers
  const lines = code.split('\n');
  const linesOfCode = lines.length;
  
  // Generate some sample issues for demonstration
  const issues: CodeIssue[] = [];
  let complexity = Math.floor(Math.random() * 10) + 1;
  
  // Some simple patterns to check
  lines.forEach((line, index) => {
    // Check for long lines
    if (line.length > 100) {
      issues.push({
        line: index + 1,
        column: 1,
        message: 'Line exceeds recommended length of 100 characters',
        severity: 'warning',
        code: 'max-len',
      });
    }
    
    // Check for console logs in production code
    if (language === 'javascript' && line.includes('console.log')) {
      issues.push({
        line: index + 1,
        column: line.indexOf('console.log'),
        message: 'Avoid console.log statements in production code',
        severity: 'info',
        code: 'no-console',
      });
    }
    
    // Check for TODO comments
    if (line.includes('TODO')) {
      issues.push({
        line: index + 1,
        column: line.indexOf('TODO'),
        message: 'TODO comment found',
        severity: 'info',
        code: 'no-todo',
      });
    }
    
    // Check for potential complexity
    if (
      (language === 'javascript' || language === 'java' || language === 'csharp') && 
      (line.includes('if ') || line.includes('for ') || line.includes('while '))
    ) {
      complexity += 1;
    }
  });
  
  // Calculate metrics
  const maintainability = Math.max(0, 100 - (issues.length * 5) - (complexity * 2));
  const score = Math.max(0, 100 - (issues.filter(i => i.severity === 'error').length * 10) - 
                          (issues.filter(i => i.severity === 'warning').length * 3) - 
                          (complexity * 2));
  
  // Generate suggestions
  const suggestions = [
    'Consider breaking down complex functions into smaller, more manageable pieces',
    'Add meaningful comments to explain complex logic',
    'Use consistent naming conventions for variables and functions',
    'Consider adding error handling for robust code',
    'Follow the principle of single responsibility for functions and classes'
  ];
  
  if (issues.some(i => i.code === 'max-len')) {
    suggestions.push('Break long lines into multiple lines for better readability');
  }
  
  if (issues.some(i => i.code === 'no-console')) {
    suggestions.push('Replace console.log with proper logging mechanisms');
  }
  
  return {
    issues,
    metrics: {
      linesOfCode,
      complexity,
      maintainability
    },
    suggestions: suggestions.slice(0, 4 + Math.floor(Math.random() * 2)), // Random subset of suggestions
    score
  };
};

// Generate a detailed report from the analysis results
export const generateReport = (result: AnalysisResult, language: SupportedLanguage): string => {
  const { issues, metrics, suggestions, score } = result;
  
  const report = `
# Code Quality Report

## Summary
- Language: ${language.toUpperCase()}
- Quality Score: ${score}/100
- Lines of Code: ${metrics.linesOfCode}
- Complexity: ${metrics.complexity}/10
- Maintainability: ${metrics.maintainability}/100

## Issues Found
${issues.length > 0 
  ? issues.map(issue => `- **${issue.severity.toUpperCase()}** Line ${issue.line}: ${issue.message}`).join('\n')
  : '- No issues found. Great job!'}

## Improvement Suggestions
${suggestions.map(suggestion => `- ${suggestion}`).join('\n')}

## Next Steps
1. Address the highlighted issues
2. Consider the improvement suggestions
3. Re-run the analysis to track progress

_Generated by Quality Maven ${new Date().toLocaleDateString()}_
  `;
  
  return report;
};
